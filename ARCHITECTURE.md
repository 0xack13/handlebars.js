HTMLbars consists of many different layers.

Consider the following template:

    <p class="user {{user.cssClass}}">
      User: {{user.name}}
      <button {{onclick "like"}}>Like</button>
    </p>

1. Parse template into a Handlebars AST. 
2. Convert only vanilla Handlebars AST into HTML-aware HTMLbars AST.

## Parse with vanilla Handlebars

Handlebars has no knowledge/concept of the DOM or DOM elements, and the AST
that it generates consists only of text nodes, mustache nodes, etc., and
doesn't distinguish between mustaches that occur within an element's
content or within the elements tag itself (or within a tag's attribute
value). 

The above vanilla HB AST looks something like:

    Program
      Content: '<p class="user '
      Mustache: `user.cssClass`
      Content: '"> User: '
      Mustache: `user.name`
      Content: ' <button '
      Mustache: `onclick` params=[`"like"`]
      Content: '>Like</button> </p>'

## Convert to HTMLBars AST

The whole point of HTMLbars is to add HTML awareness, so we have
to take the AST generated by Handlebars and pass it to the HTMLbars
parser, which accepts a vanilla Handlebars AST and outputs an AST
with two main features that make it distinct from the vanilla HB AST:

1. The there are AST nodes for every DOM element
2. The mustaches are distinguished between between whether they occur
   a) within an element's content (e.g. `<p>Hello {{name}}!</p>`), 
   b) within an element tag (e.g. `<p {{some-helper}}>...</p>`)
   or c) within an attribute's value (e.g. `<p class="user {{user.cssClass}}">...</p>`)

So the above example is restructured into an HTMLbars AST that looks
something like:

    HTMLElement tag='p' attributes=[['class', ['user ', Mustache(`user.cssClass`)]]]
      "User: "
      Mustache(`user.name`)
      " "
      HTMLElement tag='button' helpers=[Mustache(`onclick "like"`)]
        "Like"
      
## TODO: finish this


